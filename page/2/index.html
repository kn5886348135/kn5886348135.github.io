<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="https://www.goodserendipity.com/asserts/favicon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="https://www.goodserendipity.com/asserts/favicon.png">
  <link rel="icon" type="image/png" sizes="16x16" href="https://www.goodserendipity.com/asserts/favicon.png">
  <link rel="mask-icon" href="https://www.goodserendipity.com/asserts/favicon.png" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"www.goodserendipity.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="缘分天注定">
<meta property="og:url" content="https://www.goodserendipity.com/page/2/index.html">
<meta property="og:site_name" content="缘分天注定">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Louis">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://www.goodserendipity.com/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>缘分天注定</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --></head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">缘分天注定</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">古之立大事者，不惟有超世之才，亦必有坚忍不拔之志</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://www.goodserendipity.com/2023/08/02/Java/Basic/1%E3%80%81ConCurrentSkipListSet/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Louis">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="缘分天注定">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/08/02/Java/Basic/1%E3%80%81ConCurrentSkipListSet/" class="post-title-link" itemprop="url">ConCurrentSkipListSet</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-08-02 09:33:03 / Modified: 18:10:28" itemprop="dateCreated datePublished" datetime="2023-08-02T09:33:03+08:00">2023-08-02</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>  ConCurrentSkipListSet是一个基于ConCurrentSkipListMap实现的可扩展的NavigableSet。set中的元素按照自然顺序、构造函数传入的Comparator排序。JDK中的这个类是由<a target="_blank" rel="noopener" href="https://gee.cs.oswego.edu/">Doug Lea</a>实现的，这个实现提供了contains、add、remove操作预期的平均时间复杂度<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Θ</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Theta(logn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，并且是线程安全的。<font color="red">Iterator和Spliterator是弱一致的，升序视图和迭代器比降序要快。(为什么？Spliterator是什么？)</font></p>
<p>  与多数集合不同，size方法不是常数时间复杂度。因为并发集合的异步特点，确定当前集合数量需要遍历元素，所以在集合正在被修改时遍历元素会报告不准确的结果。批量操作addAll、removeAll、retainAll、containsAll、equals、toArray不保证以原子方式执行。例如迭代器遍历和addAll同时进行时可能仅查看到部分添加的元素。这个类实现了Set、Iterator接口的所有可选方法，和其他大多数并发集合一样，不支持新增null元素，因为null作为key或者返回值不能和缺少元素区可靠地分开。</p>
<p>  ConCurrentSkipListMap是SkipList的并发变种实现，containsKey、get、put、remove等其他变种操作的期望平均时间复杂度都是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Θ</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Theta(logn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>。插入、删除、更新和访问操作都支持多线程安全地并发执行，基于多层链表向右、向下的特点，是一种无锁并发实现。所有这个类中的方法返回的Map.Entry键值对和视图表示当时的快照，不支持Entry.setValue方法，但是可以使用put、putIfAbsent或者replace修改。</p>
<p>  ConCurrentSkipListMap实现了一个树状二维链接跳跃列表，其中索引级别在与保存数据的基本节点不同的节点中表示。 采用这种方法而不是通常的基于数组的结构有两个原因：1）基于数组的实现似乎会遇到更多的复杂性和开销2）对于频繁遍历的索引列表，我们可以使用比基本列表更便宜的算法。</p>
<figure class="highlight java"><figcaption><span>Doc</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Head nodes          Index nodes</span><br><span class="line">+-+    right        +-+                      +-+</span><br><span class="line">|<span class="number">2</span>|----------------&gt;| |---------------------&gt;| |-&gt;<span class="literal">null</span></span><br><span class="line">+-+                 +-+                      +-+</span><br><span class="line">| down              |                        |</span><br><span class="line">v                   v                        v</span><br><span class="line">+-+            +-+  +-+       +-+            +-+       +-+</span><br><span class="line">|<span class="number">1</span>|-----------&gt;| |-&gt;| |------&gt;| |-----------&gt;| |------&gt;| |-&gt;<span class="literal">null</span></span><br><span class="line">+-+            +-+  +-+       +-+            +-+       +-+</span><br><span class="line">v              |    |         |              |         |</span><br><span class="line">Nodes  next     v    v         v              v         v</span><br><span class="line">+-+  +-+  +-+  +-+  +-+  +-+  +-+  +-+  +-+  +-+  +-+  +-+</span><br><span class="line">| |-&gt;|A|-&gt;|B|-&gt;|C|-&gt;|D|-&gt;|E|-&gt;|F|-&gt;|G|-&gt;|H|-&gt;|I|-&gt;|J|-&gt;|K|-&gt;<span class="literal">null</span></span><br><span class="line">+-+  +-+  +-+  +-+  +-+  +-+  +-+  +-+  +-+  +-+  +-+  +-+</span><br></pre></td></tr></table></figure>
<p>  基础列表使用HM算法的变种(a variant of the HM linked ordered set algorithm)，参考Tim Harris <a target="_blank" rel="noopener" href="https://www.cl.cam.ac.uk/research/srg/netos/papers/2001-caslists.pdf">A pragmatic implementation of non-blocking linked lists</a>和Maged Michael <a target="_blank" rel="noopener" href="https://docs.rs/crate/crossbeam/0.2.4/source/hash-and-skip.pdf">High Performance Dynamic Lock-Free Hash Tables and List-Based Sets</a>。这些列表的基本思想是标记已删除节点的next指针，避插入时的并发冲突，以及遍历时跟踪三元组（前驱节点、当前节点、后继节点）以便检测何时以及如何取消链接这些已删除的节点。</p>
<p>  节点使用直接可CAS的next指针而不是使用标记位来标记列表删除（使用 AtomicMarkedReference 会很慢并且占用空间）。删除时，它们拼接到另一个可以被认为代表一个标记指针的节点中（通过使用其他不可能的字段值表示），而不是标记一个指针。使用普通节点大致类似于标记指针的&quot;装箱&quot;实现，但仅在删除节点时才使用新节点，而不是每个节点都使用新节点关联。这需要更少的空间并支持更快遍历。即使JVM更好地支持标记引用，使用这种技术的遍历可能仍然更快，因为任何搜索只需要比其他所需的节点（检查尾随标记）多预读一个节点，而不是在每次读取时取消屏蔽标记位或其他内容。</p>
<p>  这种方法保留了 HM 算法中所需的基本属性，即更改已删除节点的下一个指针，以便该节点的任何其他 CAS 都会失败，但通过更改指针以指向不同的节点来实现该想法，而不是通过标记它 。虽然可以通过定义不具有键/值字段的标记节点来进一步压缩空间，但不值得额外的类型测试开销。 删除标记在遍历过程中很少遇到，并且通常会很快被垃圾收集。（请注意，此技术在没有垃圾收集的系统中无法正常工作。）</p>
<p>  除了使用删除标记之外，列表还使用值字段的空值来指示删除，其风格类似于典型的延迟删除方案。如果节点的值为 null，则即使它仍然可访问，它也会被视为逻辑上已删除并被忽略。这可以保持对并发替换与删除操作的正确控制——如果删除通过使字段为空，则replace的尝试必须失败，并且删除必须返回字段中保存的最后一个非空值。 （注意：此处使用 Null，而不是某些特殊标记，因为它恰好符合 Map API 的要求，即如果没有映射，则方法 get 返回 null，这允许节点即使在删除时仍保持并发可读 .在这里使用任何其他标记值在最坏情况下会很混乱。）</p>
<p>  删除带有前驱节点b，后继节点f的节点n的事件，初始状态</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">     +------+       +------+      +------+</span><br><span class="line">...  |   b  |------&gt;|   n  |-----&gt;|   f  | ...</span><br><span class="line">     +------+       +------+      +------+</span><br></pre></td></tr></table></figure>
<ol>
<li>CAS操作n 的 value 字段从非 null 变为 null。从此时起，遇到该节点的任何公共操作都不会认为此映射存在。但是，其他正在进行的插入和删除操作仍可能会修改 n 的next指针。</li>
<li>CAS操作n的next指针指向新的标记节点。从此时起，n 上不能再添加其他节点。这避免了基于 CAS 的链表中的删除错误。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">     +------+       +------+      +------+       +------+</span><br><span class="line">...  |   b  |------&gt;|   n  |-----&gt;|marker|------&gt;|   f  | ...</span><br><span class="line">     +------+       +------+      +------+       +------+</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>CAS操作 b 的下一个指针位于 n 及其标记上。从此时起，不再有新的遍历遇到n，并且n和marker最终可以被GC。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">     +------+                                    +------+</span><br><span class="line">...  |   b  |-----------------------------------&gt;|   f  | ...</span><br><span class="line">     +------+                                    +------+</span><br></pre></td></tr></table></figure>
<p>  步骤 1 的失败会导致简单的重试，因为与其他操作的竞争失败。 步骤 2-3 可能会失败，因为其他一些线程在遍历期间注意到具有空值的节点并通过标记和/或取消链接来帮助解决。 这种帮助确保没有线程会因等待删除线程的进度而卡住。标记节点的使用使帮助代码稍微复杂化，因为遍历必须跟踪最多四个节点（b，n，marker，f）的一致读取，而不仅仅是（b，n，f），尽管标记的下一个字段是不可变的，并且一旦下一个字段被CAS操作指向a 标记，它永远不会再改变，所以这需要较少的关注。</p>
<p>  跳过列表向该方案添加索引，以便基本级别遍历从靠近被发现、插入或删除的位置开始——通常基本级别遍历仅遍历几个节点。 这不会改变基本算法，除了需要确保基本遍历从未（结构上）删除的前辈（此处为 b）开始，否则在处理删除后重试。</p>
<p>  索引层级被维护为具有volatile修饰的next字段的列表，使用 CAS 进行链接和取消链接。索引列表操作中允许存在竞争，这些竞争（很少）可能无法链接到新索引节点或删除索引节点。（当然，我们不能对数据节点执行此操作。）但是，即使发生这种情况，索引列表仍保持有序，因此可以正确地用作索引。这可能会影响性能，但由于跳跃列表是概率性的，因此最终结果是在争用情况下，有效“p”值可能低于其标称值。而且竞争窗口保持得足够小，因此在实践中，即使在很多竞争的情况下，这些失败也很少见。</p>
<p>  由于索引，重试（对于基列表和索引列表）相对便宜，这一事实允许对重试逻辑进行一些小的简化。遍历重新启动是在大多数“帮助”CAS 后执行的。 这并不总是绝对必要的，但隐式回退往往有助于减少其他下游失败的 CAS，足以超过重新启动成本。这使最坏的情况变得更糟，但似乎甚至改善了激烈竞争的情况。</p>
<p>  与大多数跳跃列表实现不同，这里的索引插入和删除需要在基本级别操作之后发生单独的遍历，以添加或删除索引节点。 这增加了单线程开销，但通过缩小干扰窗口来提高竞争的多线程性能，并允许删除以确保从公共删除操作返回时所有索引节点都将变得不可访问，从而避免不必要的垃圾保留。 这在这里比在其他一些数据结构中更重要，因为我们无法将引用用户键的节点字段清空，因为它们可能仍会被其他正在进行的遍历读取。</p>
<p>  索引使用跳过列表参数，在使用比平常稀疏的索引的同时保持良好的搜索性能：硬连线参数 k=1，p=0.5（参见方法 doPut）意味着大约四分之一的节点具有索引。 在那些这样做的人中，一半有一个级别，四分之一有两个级别，依此类推（参见 Pugh 的 Skip List Cookbook，第 3.4 节）。 映射的预期总空间需求略小于 java.util.TreeMap 的当前实现。</p>
<p>  更改索引的级别（即树状结构的高度）也使用 CAS。 头部索引的初始级别/高度为 1。 创建高度大于当前级别的索引时，会通过在新的最顶层头部上执行 CAS 操作，为头部索引添加一个级别。 为了在大量删除后保持良好的性能，如果最顶层似乎是空的，删除方法会试探性地尝试降低高度。这可能会遇到可能（但很少见）降低并“丢失”一个级别的竞争。 即将包含一个索引（这样就永远不会遇到）。 这不会造成结构性损害，而且在实践中似乎是比允许水平不受限制增长更好的选择。</p>
<p>  所有这些的代码比您想要的更冗长。 大多数操作需要定位元素（或插入元素的位置）。 执行此操作的代码无法很好地分解出来，因为后续使用需要前驱和/或后继和/或值字段的快照，而这些字段无法一次全部返回，至少在不创建另一个对象来保存它们的情况下无法返回 – 对于基本的内部搜索操作来说，创建如此小的对象是一个特别糟糕的主意，因为它会增加 GC 开销。 （这是我为数不多的希望 Java 有宏的情况之一。）相反，一些遍历代码在插入和删除操作中交错进行。 处理所有重试条件的控制逻辑有时是曲折的。 大多数搜索分为两部分。 findPredecessor() 仅搜索索引节点，返回键的基本级前驱。 findNode() 完成基本级别的搜索。 即使进行了这种分解，仍然存在大量近乎重复的代码来处理变体。</p>
<p>  为了生成随机值而不跨线程干扰，我们使用 JDK 内线程本地随机支持（通过“二级种子”，以避免干扰用户级 ThreadLocalRandom。）</p>
<p>  该类的早期版本将不可比较的键与其比较器一起包装，以在使用比较器与可比较对象时模拟可比较对象。 然而，JVM 现在似乎可以更好地处理将比较器与可比较的选择注入搜索循环中。 静态方法 cpr(comparator, x, y) 用于所有比较，只要比较器参数设置在循环之外（因此有时作为参数传递给内部方法），该方法就可以很好地工作，以避免字段重新读取。</p>
<p>  与该算法功能相似的论文，<a target="_blank" rel="noopener" href="http://www.cse.yorku.ca/~ruppert/Mikhail.pdf">Mikhail Fomitchev的论文</a>，<a target="_blank" rel="noopener" href="https://www.cl.cam.ac.uk/techreports/UCAM-CL-TR-579.pdf">Keir Fraser的论文</a>, <a target="_blank" rel="noopener" href="https://research.chalmers.se/en/person/phs">Hakan Sundell的论文</a>。</p>
<p>  鉴于使用了树状索引节点，您可能想知道为什么不使用某种搜索树来代替，这将支持更快的搜索操作。原因是没有已知的有效的搜索树无锁插入和删除算法。索引节点“向下”链接的不变性（与真实树中可变的“左”字段相反）使得仅使用 CAS 操作即可处理此问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 变量的解释</span></span><br><span class="line">Node:         b, n, f    <span class="keyword">for</span>  predecessor, node, successor</span><br><span class="line">Index:        q, r, d    <span class="keyword">for</span> index node, right, down.</span><br><span class="line">              t          <span class="keyword">for</span> another index node</span><br><span class="line">Head:         h</span><br><span class="line">Levels:       j</span><br><span class="line">Keys:         k, key</span><br><span class="line">Values:       v, value</span><br><span class="line">Comparisons:  c</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SkipList的节点</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;K,V&gt; &#123;</span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line">        <span class="keyword">volatile</span> Object value;</span><br><span class="line">        <span class="keyword">volatile</span> Node&lt;K,V&gt; next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 表示链表层级的节点</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Index</span>&lt;K,V&gt; &#123;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;K,V&gt; node;</span><br><span class="line">        <span class="keyword">final</span> Index&lt;K,V&gt; down;</span><br><span class="line">        <span class="keyword">volatile</span> Index&lt;K,V&gt; right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  Java语法中break outer，break splice的用法？</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://www.goodserendipity.com/2023/08/01/DataStructuresAndAlgorithms/33%E3%80%81%E5%AF%B9%E6%95%B0%E5%99%A8%E5%92%8C%E5%88%86%E6%B2%BB1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Louis">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="缘分天注定">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/08/01/DataStructuresAndAlgorithms/33%E3%80%81%E5%AF%B9%E6%95%B0%E5%99%A8%E5%92%8C%E5%88%86%E6%B2%BB1/" class="post-title-link" itemprop="url">对数器和分治</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-08-01 14:46:24" itemprop="dateCreated datePublished" datetime="2023-08-01T14:46:24+08:00">2023-08-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-08-12 17:58:48" itemprop="dateModified" datetime="2023-08-12T17:58:48+08:00">2023-08-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">数据结构与算法</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="对数器找规律"><a class="markdownIt-Anchor" href="#对数器找规律"></a> 对数器找规律</h3>
<ol>
<li>输入参数类型简单，并且只有一个实际参数</li>
<li>要求的返回值类型也简单，并且只有一个</li>
<li>用暴力方法，把输入参数对应的返回值，打印出来看看，进而优化code</li>
</ol>
<h3 id="两个袋子装苹果"><a class="markdownIt-Anchor" href="#两个袋子装苹果"></a> 两个袋子装苹果</h3>
<p>  小虎去买苹果，商店只提供两种类型的塑料袋，每种类型都有任意数量。这两种袋子分别是能装下6个苹果的袋子和能装下8个苹果的袋子。小虎可以自由使用两种袋子来装苹果，但是小虎有强迫症，他要求自己使用的袋子数量必须最少，且使用的每个袋子必须装满。<br />
  给定一个正整数N，返回至少使用多少袋子。如果N无法让使用的每个袋子必须装满，返回-1。</p>
<h3 id="牛和羊吃草"><a class="markdownIt-Anchor" href="#牛和羊吃草"></a> 牛和羊吃草</h3>
<p>  给定一个正整数N，表示有N份青草统一堆放在仓库里。有一只牛和一只羊，牛先吃，羊后吃，它俩轮流吃草。不管是牛还是羊，每一轮能吃的草量必须是：1，4，16，64…(4的某次方)。谁最先把草吃完，谁获胜。假设牛和羊都绝顶聪明，都想赢，都会做出理性的决定。根据唯一的参数N，返回谁会赢。</p>
<h3 id="连续正数和的数"><a class="markdownIt-Anchor" href="#连续正数和的数"></a> 连续正数和的数</h3>
<p>  定义一种数：可以表示成若干（数量&gt;1）连续正数和的数。比如:5 = 2+3，5就是这样的数，12 = 3+4+5，12就是这样的数。1不是这样的数，因为要求数量大于1个、连续正数和。2 = 1 + 1，2也不是，因为等号右边不是连续正数。给定一个参数N，返回是不是可以表示成若干连续正数和的数。</p>
<h3 id="根据数据规模猜解法"><a class="markdownIt-Anchor" href="#根据数据规模猜解法"></a> 根据数据规模猜解法</h3>
<ol>
<li>C/C++，1秒处理的指令条数为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>8</mn></msup></mrow><annotation encoding="application/x-tex">10^8</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">8</span></span></span></span></span></span></span></span></span></span></span></li>
<li>Java等语言，1~4秒处理的指令条数为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>8</mn></msup></mrow><annotation encoding="application/x-tex">10^8</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">8</span></span></span></span></span></span></span></span></span></span></span></li>
<li>利用数据规模判断处理时间</li>
</ol>
<h3 id="花钱最少打怪兽"><a class="markdownIt-Anchor" href="#花钱最少打怪兽"></a> 花钱最少打怪兽</h3>
<p>  int[] d，d[i]：i号怪兽的能力，int[] p，p[i]：i号怪兽要求的钱。开始时你的能力是0，你的目标是从0号怪兽开始，通过所有的怪兽。如果你当前的能力，小于i号怪兽的能力，你必须付出p[i]的钱，贿赂这个怪兽，然后怪兽就会加入你，他的能力直接累加到你的能力上；如果你当前的能力，大于等于i号怪兽的能力，你可以选择直接通过，你的能力并不会下降，你也可以选择贿赂这个怪兽，然后怪兽就会加入你，他的能力直接累加到你的能力上。返回通过所有的怪兽，需要花的最小钱数。</p>
<h3 id="根据数据状况猜解法续-以及分治"><a class="markdownIt-Anchor" href="#根据数据状况猜解法续-以及分治"></a> 根据数据状况猜解法（续）、以及分治</h3>
<p><strong>分治算法的应用场景</strong></p>
<ol>
<li>数据量整体做尝试可能性太多，跑不完</li>
<li>数据分成多个块（常见是两块）之后，各自的可能性并不算多</li>
<li>合并多个块各自信息的整合过程不复杂</li>
</ol>
<h3 id="子序列累加和模m的最大值"><a class="markdownIt-Anchor" href="#子序列累加和模m的最大值"></a> 子序列累加和模m的最大值</h3>
<p>  给定一个非负数组arr，和一个正数m。返回arr的所有子序列中累加和模m之后的最大值。</p>
<h3 id="背包放零食"><a class="markdownIt-Anchor" href="#背包放零食"></a> 背包放零食</h3>
<p>  牛牛家里一共有n袋零食, 第i袋零食体积为v[i]，背包容量为w。牛牛想知道在总体积不超过背包容量的情况下,一共有多少种零食放法，体积为0也算一种放法。1 ≤ n ≤ 30, 1 ≤ w ≤ <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup></mrow><annotation encoding="application/x-tex">2 \times 10^9</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span></span></span></span>，v[i] (0 ≤ v[i] ≤ <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup></mrow><annotation encoding="application/x-tex">10^9</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span></span></span></span>）</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://www.goodserendipity.com/2023/08/01/DataStructuresAndAlgorithms/34%E3%80%81%E5%8D%A1%E7%89%B9%E5%85%B0%E6%95%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Louis">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="缘分天注定">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/08/01/DataStructuresAndAlgorithms/34%E3%80%81%E5%8D%A1%E7%89%B9%E5%85%B0%E6%95%B0/" class="post-title-link" itemprop="url">卡特兰数</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-08-01 14:46:24" itemprop="dateCreated datePublished" datetime="2023-08-01T14:46:24+08:00">2023-08-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-08-12 18:01:55" itemprop="dateModified" datetime="2023-08-12T18:01:55+08:00">2023-08-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">数据结构与算法</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="卡特兰数"><a class="markdownIt-Anchor" href="#卡特兰数"></a> 卡特兰数</h3>
<p>  卡特兰数又称卡塔兰数，英文名Catalan number，是组合数学中一个常出现在各种计数问题中出现的数列。其前几项为：1, 1, 2, 5, 14, 42, 132, 429, 1430, 4862, 16796, 58786, 208012, 742900, 2674440, 9694845, 35357670, 129644790, 477638700, 1767263190, 6564120420, 24466267020, 91482563640, 343059613650, 1289904147324, 4861946401452, …<br />
  k(0) = 1, k(1) = 1时，如果接下来的项满足：k(n) = k(0) <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>×</mo></mrow><annotation encoding="application/x-tex">\times</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord">×</span></span></span></span> k(n - 1) + k(1) <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>×</mo></mrow><annotation encoding="application/x-tex">\times</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord">×</span></span></span></span> k(n - 2) + … + k(n - 2) <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>×</mo></mrow><annotation encoding="application/x-tex">\times</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord">×</span></span></span></span> k(1) + k(n - 1) <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>×</mo></mrow><annotation encoding="application/x-tex">\times</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord">×</span></span></span></span> k(0)或者k(n) = C(2n, n) - C(2n, n-1)或者k(n) = <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mi>C</mi><mo stretchy="false">(</mo><mn>2</mn><mi>n</mi><mo separator="true">,</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><mrow><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{C(2n, n)}{(n + 1)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.53em;vertical-align:-0.52em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">n</span><span class="mbin mtight">+</span><span class="mord mtight">1</span><span class="mclose mtight">)</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.07153em;">C</span><span class="mopen mtight">(</span><span class="mord mtight">2</span><span class="mord mathnormal mtight">n</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight">n</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.52em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>，C是排列组合。就说这个表达式，满足卡特兰数，常用的是范式1和2，3几乎不会使用到。</p>
<h3 id="前缀串1比0多"><a class="markdownIt-Anchor" href="#前缀串1比0多"></a> 前缀串1比0多</h3>
<p>  假设给你N个0，和N个1，你必须用全部数字拼序列。返回有多少个序列满足：任何前缀串，1的数量都不少于0的数量。(0换成左括号(，1换成右括号))</p>
<h3 id="不同二叉树数量"><a class="markdownIt-Anchor" href="#不同二叉树数量"></a> 不同二叉树数量</h3>
<p>  有N个二叉树节点，每个节点彼此之间无任何差别。返回由N个二叉树节点，组成的不同结构数量是多少？</p>
<p>  卡特兰数的算法原型在解决问题时需要观察(人员站队问题、出栈入栈问题)</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://www.goodserendipity.com/2023/08/01/DataStructuresAndAlgorithms/39%E3%80%81Suffix%20Array/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Louis">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="缘分天注定">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/08/01/DataStructuresAndAlgorithms/39%E3%80%81Suffix%20Array/" class="post-title-link" itemprop="url">Suffix Array</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-08-01 14:44:05" itemprop="dateCreated datePublished" datetime="2023-08-01T14:44:05+08:00">2023-08-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-08-13 00:25:11" itemprop="dateModified" datetime="2023-08-13T00:25:11+08:00">2023-08-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">数据结构与算法</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>  <a target="_blank" rel="noopener" href="https://oi-wiki.org/string/sa/">后缀数组</a>是字符串所有后缀的排序数组。 它是一种用于全文索引、数据压缩算法和文献计量学等领域的数据结构。</p>
<p>  <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Suffix_array">Suffix Array</a>由 Manber &amp; Myers (1990)的论文<a href="https://www.goodserendipity.com/asserts/data-structures-and-algorithms/Suffix%20arrays%20a%20new%20method%20for%20on-line%20string%20searches.pdf">Suffix arrays a new method for on-line string searches</a> 引入，作为后缀树的一种简单且节省空间的替代方案。 它们是由 Gaston Gonnet 于 1987 年独立发现的，名为 PAT 阵列（Gonnet、Baeza-Yates &amp; Snider 1992）。</p>
<p>  <a target="_blank" rel="noopener" href="https://zhizeli.github.io/">李志泽</a>、李建和霍红卫在2016年的论文<a href="https://www.goodserendipity.com/asserts/data-structures-and-algorithms/Optimal_inplace_suffix_sorting_Zhize_Li.pdf">Optimal In-Place Suffix Sorting</a>给出了第一个时间复杂度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Θ</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Theta(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 、空间复杂度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Θ</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Theta(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 的后缀数组构造算法，该算法在时间和空间上都是最优的。</p>
<p>  增强型后缀数组 (ESA) 是带有附加表的后缀数组，可重现后缀树的完整功能，同时保留相同的时间和内存复杂性。字符串所有后缀的子集的后缀数组称为稀疏后缀数组。人们已经开发了多种概率算法来最大限度地减少额外的内存使用，包括最佳时间和内存算法。</p>
<p>  后缀数组（Suffix Array）主要关系到两个数组：sa 和 rk。其中，sa[i] 表示将所有后缀排序后第 i 小的后缀的编号，也是所说的后缀数组，后文也称编号数组 sa；rk[i] 表示后缀 i 的排名，是重要的辅助数组，后文也称排名数组 rk。这两个数组满足性质：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>a</mi><mo stretchy="false">[</mo><mi>r</mi><mi>k</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">]</mo><mo>=</mo><mi>r</mi><mi>k</mi><mo stretchy="false">[</mo><mi>s</mi><mi>a</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">]</mo><mo>=</mo><mi>i</mi></mrow><annotation encoding="application/x-tex">sa[rk[i]] = rk[sa[i]] = i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">a</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mopen">[</span><span class="mord mathnormal">s</span><span class="mord mathnormal">a</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span></span></span></span>。<br />
<img src="https://www.goodserendipity.com/asserts/data-structures-and-algorithms/suffix%20array1.png" alt="sa和rk的示例" /></p>
<p>  后缀数组有几种不同时间复杂度的实现，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Θ</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo>×</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Theta(n^2 \times logn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 、<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Θ</mi><mo stretchy="false">(</mo><mi>n</mi><mo>×</mo><mi>l</mi><mi>o</mi><msup><mi>g</mi><mrow><mn>2</mn><mi>n</mi></mrow></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Theta(n \times log^{2n})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 、<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Θ</mi><mo stretchy="false">(</mo><mi>n</mi><mo>×</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Theta(n \times logn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 、<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Θ</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Theta(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> ，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Θ</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Theta(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 时间复杂度的算法有<a target="_blank" rel="noopener" href="https://riteme.site/blog/2016-6-19/sais.html">SA-IS</a>和DC3等。</p>
<h3 id="leetcode1163-按字典序排在最后的子串"><a class="markdownIt-Anchor" href="#leetcode1163-按字典序排在最后的子串"></a> LeetCode1163 按字典序排在最后的子串</h3>
<p>  给你一个字符串 s ，找出它的所有子串并按字典序排列，返回排在最后的那个子串。</p>
<h3 id="最大字典序"><a class="markdownIt-Anchor" href="#最大字典序"></a> 最大字典序</h3>
<p>  给定两个字符串str1和str2，想把str2整体插入到str1中的某个位置，形成最大的字典序返回字典序最大的结果。<font color="red">str1的长度远大于str2的长度?</font></p>
<h3 id="k个正数拼接最大值"><a class="markdownIt-Anchor" href="#k个正数拼接最大值"></a> K个正数拼接最大值</h3>
<p>  给两个长度分别为M和N的整型数组nums1和nums2，其中每个值都不大于9，再给定一个正数K。 你可以在nums1和nums2中挑选数字，要求一共挑选K个，并且要从左到右挑。返回所有可能的结果中，代表最大数字的结果。</p>
<h3 id="最长公共子串"><a class="markdownIt-Anchor" href="#最长公共子串"></a> 最长公共子串</h3>
<p>  最长公共子串问题是面试常见题目之一，假设str1长度N，str2长度M，求最长公共子串的长度。动态规划可以达到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Θ</mi><mo stretchy="false">(</mo><mi>N</mi><mo>×</mo><mi>M</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Theta(N \times M)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mclose">)</span></span></span></span> 时间复杂度，但最优解后缀数组加height数组可以达到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Θ</mi><mo stretchy="false">(</mo><mi>N</mi><mo>+</mo><mi>M</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Theta(N+M)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mclose">)</span></span></span></span> 时间复杂度。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://www.goodserendipity.com/2023/08/01/DataStructuresAndAlgorithms/32%E3%80%81B+Tree/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Louis">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="缘分天注定">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/08/01/DataStructuresAndAlgorithms/32%E3%80%81B+Tree/" class="post-title-link" itemprop="url">B+Tree</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-08-01 14:35:05" itemprop="dateCreated datePublished" datetime="2023-08-01T14:35:05+08:00">2023-08-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-08-12 20:42:21" itemprop="dateModified" datetime="2023-08-12T20:42:21+08:00">2023-08-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">数据结构与算法</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>  <a target="_blank" rel="noopener" href="https://oi-wiki.org/ds/bplus-tree/">B+ 树</a>(<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/B-tree">B+Tree</a>)是一种 m 叉排序树，降低了索引结构的深度，避免传统二叉树结构中绝大部分的随机访问操作，从而有效减少了磁盘磁头的寻道次数，降低了外存访问延迟对性能的影响。每个节点的子节点数量可变，但通常有大量子节点。B+ 树由根、内部节点和叶子组成。根可以是叶子，也可以是具有两个或更多子节点的节点。B+树是1970年Rudolf Bayer教授在<a href="https://www.goodserendipity.com/asserts/data-structures-and-algorithms/Organization%20and%20maintenance%20of%20large%20ordered%20indices.pdf">Organization and Maintenance of Large Ordered Indices</a>中提出的。<a target="_blank" rel="noopener" href="https://github.com/begeekmyfriend/bplustree">B+Tree的C++实现bplustree</a>。</p>
<p>  B+ 树可以被视为 B 树，但每个节点仅包含键（而不是键值对），并且在底部添加了具有链接叶子节点的指针。</p>
<p>  B+ 树的主要价值在于存储数据，以便在面向块的存储上下文（特别是文件系统）中进行高效检索。 这主要是因为与二叉搜索树不同，B+ 树具有非常高的扇出（节点中指向子节点的指针数量，通常约为 100 或更多），这减少了在树中找到一个元素所需的 I/O 操作次数。B+ 树比 B 树更适合实际应用中操作系统的文件索引和数据库索引。目前现代关系型数据库最广泛的支持索引结构就是 B+ 树。</p>
<p>  B+ 树的特点是能够保持数据稳定有序，其插入与修改拥有较稳定的对数时间复杂度。B+ 树元素自底向上插入，这与二叉树恰好相反。</p>
<h3 id="btree的性质"><a class="markdownIt-Anchor" href="#btree的性质"></a> B+Tree的性质</h3>
<ol>
<li>有 n 棵子树的节点中含有 n-1 个关键字（即将区间分为 n 个子区间，每个子区间对应一棵子树）。</li>
<li>所有叶子节点中包含了全部关键字的信息，及指向含这些关键字记录的指针，且叶子节点本身依关键字的大小自小而大顺序链接。</li>
<li>所有的非叶子节点可以看成是索引部分，节点中仅含有其子树（根节点）中的最大（或最小）关键字。</li>
<li>除根节点外，其他所有节点中所含关键字的个数最少有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">⌈</mo><mstyle displaystyle="true" scriptlevel="0"><mfrac><mi>m</mi><mn>2</mn></mfrac></mstyle><mo stretchy="false">⌉</mo></mrow><annotation encoding="application/x-tex">\lceil \dfrac{m}{2} \rceil</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.7935600000000003em;vertical-align:-0.686em;"></span><span class="mopen">⌈</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.10756em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">⌉</span></span></span></span>（注意：B 树中除根以外的所有非叶子节点至少有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">⌈</mo><mstyle displaystyle="true" scriptlevel="0"><mfrac><mi>m</mi><mn>2</mn></mfrac></mstyle><mo stretchy="false">⌉</mo></mrow><annotation encoding="application/x-tex">\lceil \dfrac{m}{2} \rceil</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.7935600000000003em;vertical-align:-0.686em;"></span><span class="mopen">⌈</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.10756em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">⌉</span></span></span></span> 棵子树）。</li>
<li>B+ 树为了方便范围查询，叶子节点之间还用指针串联起来。</li>
</ol>
<h3 id="b-树相比于-b-树的优势"><a class="markdownIt-Anchor" href="#b-树相比于-b-树的优势"></a> B+ 树相比于 B 树的优势</h3>
<ol>
<li>由于索引节点上只有索引而没有数据，所以索引节点上能存储比 B 树更多的索引，这样树的高度就会更矮。树的高度越矮，磁盘寻道的次数就会越少。</li>
<li>因为数据都集中在叶子节点，而所有叶子节点的高度相同，那么可以在叶子节点中增加前后指针，指向同一个父节点的相邻兄弟节点，这样可以更好地支持查询一个值的前驱或后继，使连续访问更容易实现。</li>
</ol>
<p>  比如这样的 SQL 语句：select * from tbl where t &gt; 10，如果使用 B+ 树存储数据的话，可以首先定位到数据为 10 的节点，再沿着它的 next 指针一路找到所有在该叶子节点右边的叶子节点，返回这些节点包含的数据。而如果使用 B 树结构，由于数据既可以存储在内部节点也可以存储在叶子节点，连续访问的实现会更加繁琐（需要在树的内部结构中进行移动）。</p>
<h3 id="b-tree的查找"><a class="markdownIt-Anchor" href="#b-tree的查找"></a> B+ Tree的查找</h3>
<p>// TODO</p>
<h3 id="b-tree的遍历"><a class="markdownIt-Anchor" href="#b-tree的遍历"></a> B+ Tree的遍历</h3>
<p>// TODO</p>
<h3 id="b-tree的插入"><a class="markdownIt-Anchor" href="#b-tree的插入"></a> B+ Tree的插入</h3>
<p>// TODO</p>
<h3 id="b-tree的删除"><a class="markdownIt-Anchor" href="#b-tree的删除"></a> B+ Tree的删除</h3>
<p>// TODO</p>
<h3 id="btree的并发控制"><a class="markdownIt-Anchor" href="#btree的并发控制"></a> B+Tree的并发控制</h3>
<p>  索引结构作为影响系统性能的关键因素之一，对数据库系统在高并发场景下的性能表现具有重大的影响。从1970年B+树提出至今，学术界有大量论文尝试优化B+树在多线程场景下的性能，这些文章被广泛发表在数据库/系统领域顶级会议VLDB/SIGMOD/EuroSys上。<br />
<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/414141859">B+树并发控制机制的前世今生</a>讲述了B+树的并发控制历史，参考文献</p>
<ol>
<li>Bayer R, Mccreight E. <a href="https://www.goodserendipity.com/asserts/data-structures-and-algorithms/Organization%20and%20maintenance%20of%20large%20ordered%20indices.pdf">Organization and Maintenance of Large Ordered Indices</a>// ACM Sigfidet. ACM, 1970:107-141.</li>
<li>Samadi B. B-trees in a system with multiple users ☆[J]. Information Processing Letters, 1976, 5(4):107-112.</li>
<li>Bayer R, Schkolnick M. Concurrency of operations on B -trees[J]. Acta Informatica, 1977, 9(1):1-21.</li>
<li>Lehman P L, Yao S B. Efficient locking for concurrent operations on B-trees[J]. Acm Transactions on Database Systems, 1981, 6(4):650-670.</li>
<li>Memory Latencies on Intel® Xeon® Processor E5-4600 and E7-4800 product families <a target="_blank" rel="noopener" href="https://software.intel.com/en-us/blogs/2014/01/28/memory-latencies-on-intel-xeon-processor-e5-4600-and-e7-4800-product-families">https://software.intel.com/en-us/blogs/2014/01/28/memory-latencies-on-intel-xeon-processor-e5-4600-and-e7-4800-product-families</a></li>
<li>Cha S K, Hwang S, Kim K, et al. Cache-Conscious Concurrency Control of Main-Memory Indexes on Shared-Memory Multiprocessor Systems[J]. Proc of Vldb, 2001:181–190.</li>
<li>K. Fraser. Practical lock-freedom. Technical Report UCAM- CL-TR-579, University of Cambridge Computer Laboratory, 2004.</li>
<li>Mao Y, Kohler E, Morris R T. Cache craftiness for fast multicore key-value storage[C]// ACM European Conference on Computer Systems. ACM, 2012:183-196.</li>
</ol>
<h4 id="并发控制机制的基本要求"><a class="markdownIt-Anchor" href="#并发控制机制的基本要求"></a> 并发控制机制的基本要求</h4>
<ol>
<li>正确的读操作：
<ol>
<li>不会读到一个处于中间状态的键值对：读操作访问中的键值对正在被另一个写操作修改</li>
<li>不会找不到一个存在的键值对：读操作正在访问某个树节点，这个树节点上的键值对同时被另一个写操作（分裂/合并操作）移动到另一个树节点，导致读操作没有找到目标键值对</li>
</ol>
</li>
<li>正确的写操作：两个写操作不会同时修改同一个键值对</li>
<li>无死锁：不会出现死锁：两个或多个线程发生永久堵塞（等待），每个线程都在等待被其他线程占用并堵塞了的资源</li>
</ol>
<h4 id="锁分类"><a class="markdownIt-Anchor" href="#锁分类"></a> 锁分类</h4>
<ol>
<li>SL (Shared Lock): 共享锁 — 加锁</li>
<li>SU (Shared Unlock): 共享锁 — 解锁</li>
<li>XL (Exclusive Lock): 互斥锁 — 加锁</li>
<li>XU (Exclusive Unlock): 互斥锁 — 解锁</li>
<li>SXL (Shared Exclusive Lock): 共享互斥锁 — 加锁</li>
<li>SXU (Shared Exclusive Unlock): 共享互斥锁 — 解锁</li>
<li>safe nodes：判断依据为该节点上的当前操作是否会影响祖先节点。以传统B+树为例
<ol>
<li>对于插入操作，当键值对的数量小于M时，插入操作不会触发分裂操作，该节点属于safe node；反之当键值对数量等于M时，该节点属于unsafe node；</li>
<li>对于删除操作，当键值对的数量大于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mi>M</mi><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">\frac{M}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.217331em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.872331em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">M</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span> 时，不会触发合并操作，该节点属于safe node；反之当键值对数量等于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mi>M</mi><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">\frac{M}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.217331em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.872331em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">M</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span> 时，该节点属于unsafe node。当然，对于MySQL而言，一个节点是否是安全节点取决于键值对的大小和页面剩余空间大小等多个因素，详细代码可查询MySQL5.7的btr_cur_will_modify_tree()函数。</li>
</ol>
</li>
</ol>
<h3 id="lsm"><a class="markdownIt-Anchor" href="#lsm"></a> LSM</h3>
<p>  LSM Tree 则采取读写分离的策略，会优先保证写操作的性能；其数据首先存储内存中，而后需要定期 Flush 到硬盘上。LSM-Tree 通过内存插入与磁盘的顺序写，来达到最优的写性能，因为这会大大降低磁盘的寻道次数，一次磁盘 IO 可以写入多个索引块。HBase, Cassandra, RockDB, LevelDB, SQLite 等都是基于 LSM Tree 来构建索引的数据库；LSM Tree 的树节点可以分为两种，保存在内存中的称之为 MemTable, 保存在磁盘上的称之为 SSTable。</p>
<h3 id="nv-tree"><a class="markdownIt-Anchor" href="#nv-tree"></a> NV-Tree</h3>
<p>  传统B+树在NVM(non-volatile memory)上维护一致性的开销过高（相当一部分的原因是由 mfence 以及clflush 这两个指令造成的）。论文<a target="_blank" rel="noopener" href="https://www.usenix.org/system/files/conference/fast15/fast15-paper-yang.pdf">NV-Tree：Reducing Consistency Cost for NVM-based Single Level Systems</a>提出了一种新的B+Tree 结构：NV-Tree 以减少维护树结构consistency时系统的开销。<br />
  NV-Tree的节点被分成了三种类型，第一种是leaf node（LN），存储的是kv信息，也就是实实在在的数据，第二种是internal node（IN），存储的是重构信息，第三种是PLN，LN的父节点。主要操作有定位（locating）、插入、删除、更新、查找、分裂，替换以及合并（split，replace and merge）</p>
<p>  NV-Tree的设计思路</p>
<ol>
<li>选择性的数据一致性</li>
<li>LN中无序的entry</li>
<li>优化INs在NVM中的组织结构</li>
</ol>
<h3 id="适应性哈希索引"><a class="markdownIt-Anchor" href="#适应性哈希索引"></a> 适应性哈希索引</h3>
<p>  MySQL为了提高查询效率，在InnoDB中，将查询频繁的条件和索引树结果做了一个Hash映射，减少搜索B+Tree的操作。这个Hash映射就叫做自适应哈希索引(Adaptive Hash Index)，简写AHI。</p>
<h3 id="bw-tree"><a class="markdownIt-Anchor" href="#bw-tree"></a> Bw-Tree</h3>
<p>  Bw-tree 是 2013 年微软发表的论文<a target="_blank" rel="noopener" href="https://15721.courses.cs.cmu.edu/spring2017/papers/08-oltpindexes2/bwtree-icde2013.pdf">The Bw-Tree: A B-Tree for New Hardware Platforms</a>提出的数据结构。考虑到多核机器和 SSD 日趋普及，结合两大存储引擎 B±tree 和 LSM-tree 特点，提出了这种 latch-free、delta update、log structured 的 B族树 —— Bw-tree。<a target="_blank" rel="noopener" href="https://github.com/wangziqi2013/BwTree">代码实现</a></p>
<p>Bw tree 的主要特点</p>
<ol>
<li>总体分三层：bwtree 索引层，缓存控制层和 Flash 存储层。</li>
<li>bwtree 在整体上是一棵 B+ 树，同时借鉴了 B-link 树的思想，每个节点存在一个指向右兄弟的 side pointer。</li>
<li>bwtree 在单个树节点上表现为类似 LSM-tree 的 Log-Structure，每个逻辑节点由 a base node + a delta records chain 组成。</li>
<li>bwtree 实现 latch-free 的核心数据结构叫 Mapping Table，通过 CAS 进行 installing 操作，修改一个 mapping entry 可以同时完成多个逻辑指针的修改。</li>
<li>bwtree flash 层也使用 Log-Structure Store （append only）对逻辑页的物理存储（base page 和 delta record）进行管理。<br />
结构设计、基础操作、并发控制等参考<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/422561790">微软提出的无锁 B 族树 —— Bw-tree</a>或者上面的论文。</li>
</ol>
<h3 id="utree"><a class="markdownIt-Anchor" href="#utree"></a> uTree</h3>
<p>  B+Tree的优化多数着重于减少对NVM的flush次数，uTree从另一个角度对B+Tree进行了优化。将B+Tree保存在DRAM(Dynamic random access memory)，实际数据保存在PM(Persistent memory)中，断电后利用PM的数据在DRAM中重构B+Tree。uTree的结构设计、增删改查操作、并发控制等可以参考论文<a target="_blank" rel="noopener" href="http://storage.cs.tsinghua.edu.cn/papers/vldb20-utree.pdf/">uTree: a Persistent B±Tree with Low Tail Latency</a>。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://www.goodserendipity.com/2023/08/01/DataStructuresAndAlgorithms/31%E3%80%81B-Tree/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Louis">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="缘分天注定">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/08/01/DataStructuresAndAlgorithms/31%E3%80%81B-Tree/" class="post-title-link" itemprop="url">B-Tree</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-08-01 14:34:51" itemprop="dateCreated datePublished" datetime="2023-08-01T14:34:51+08:00">2023-08-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-08-12 18:06:22" itemprop="dateModified" datetime="2023-08-12T18:06:22+08:00">2023-08-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">数据结构与算法</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>  <a target="_blank" rel="noopener" href="https://oi-wiki.org/ds/b-tree/">B 树</a>（<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/B-tree">B-tree</a>）是一种自平衡的树，能够保持数据有序。这种数据结构能够让查找数据、顺序访问、插入数据及删除的动作，都在对数时间内完成。树用多个节点储存元素。某些节点存在一定的关系，用连线表示。二叉树是一种特殊的树，每个节点最多有两个子树。二叉树常用于实现二叉搜索树和二叉堆。 而 AVL 树 是特殊的二叉树，是最早被发明的自平衡二叉查找树。B 树保留了自平衡的特点，但 B 树的每个节点可以拥有两个以上的子节点，因此 B 树是一种多路搜索树。在 B 树中，有两种节点：</p>
<blockquote>
<p>内部节点（internal node）:存储了数据以及指向其子节点的指针。<br />
叶子节点（leaf node）:与内部节点不同的是，叶子节点只存储数据，并没有子节点。</p>
</blockquote>
<h3 id="b-tree的历史"><a class="markdownIt-Anchor" href="#b-tree的历史"></a> B-Tree的历史</h3>
<p>  B 树是由 Rudolf Bayer 和 Edward M. McCreight 在波音研究实验室工作时发明的，目的是有效管理大型随机访问文件的索引页。基本假设是索引非常庞大，以至于主内存中只能容纳树的一小部分。 Bayer 和 McCreight 的论文<a target="_blank" rel="noopener" href="https://infolab.usc.edu/csci585/Spring2010/den_ar/indexing.pdf">Organization and maintenance of large ordered indices</a> 于 1970 年 7 月首次流传，后来发表在 Acta Informatica 上。</p>
<p>  拜耳和麦克雷特从未解释过 B 代表什么（如果有的话）：波音、平衡、介于、宽阔、浓密和拜耳。McCreight 说过<strong>你越多地思考 B 树中的 B 的含义，你就越能理解 B 树。</strong></p>
<p>  2011 年，Google 开发了 C++ B 树，报告称与红黑树相比，小数据类型的内存使用量减少了 50-80%，并且提高了大数据集的性能。</p>
<h3 id="b-tree的性质"><a class="markdownIt-Anchor" href="#b-tree的性质"></a> B-Tree的性质</h3>
<ol>
<li>每个节点最多有 m 个子节点。</li>
<li>每一个非叶子节点（除根节点）最少有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">⌈</mo><mstyle displaystyle="true" scriptlevel="0"><mfrac><mi>m</mi><mn>2</mn></mfrac></mstyle><mo stretchy="false">⌉</mo></mrow><annotation encoding="application/x-tex">\lceil \dfrac{m}{2} \rceil</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.7935600000000003em;vertical-align:-0.686em;"></span><span class="mopen">⌈</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.10756em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">⌉</span></span></span></span> 个子节点。</li>
<li>如果根节点不是叶子节点，那么它至少有两个子节点。</li>
<li>有 k 个子节点的非叶子节点拥有 k−1 个键，且升序排列，满足 k[i] &lt; k[i+1]。</li>
<li>每个节点至多包含 2k-1 个键。</li>
<li>所有的叶子节点都在同一层。</li>
</ol>
<h3 id="b-tree的查找"><a class="markdownIt-Anchor" href="#b-tree的查找"></a> B-Tree的查找</h3>
<p>// TODO</p>
<h3 id="b-tree的遍历"><a class="markdownIt-Anchor" href="#b-tree的遍历"></a> B-Tree的遍历</h3>
<p>// TODO</p>
<h3 id="b-tree的插入"><a class="markdownIt-Anchor" href="#b-tree的插入"></a> B-Tree的插入</h3>
<p>// TODO</p>
<h3 id="b-tree的删除"><a class="markdownIt-Anchor" href="#b-tree的删除"></a> B-Tree的删除</h3>
<p>// TODO</p>
<h3 id="b-tree的优点"><a class="markdownIt-Anchor" href="#b-tree的优点"></a> B-Tree的优点</h3>
<ol>
<li>满足局部性原理</li>
<li>每个节点存储的数据更多</li>
<li>树的高度更低</li>
</ol>
<p>  AVL Tree，Red-Black Tree这些搜索二叉树的每个节点只能容纳一个数据，导致树的高度很高，逻辑上挨着的节点数据可能离得很远。</p>
<p>  读写磁盘与内存的不同</p>
<blockquote>
<ol>
<li>读写磁盘的速度相比内存读写慢很多。</li>
<li>每次读写磁盘的单位要比读写内存的最小单位大很多。</li>
</ol>
</blockquote>
<p>  因为读写磁盘的特点，对应的数据结构应该尽量的满足「局部性原理」：「当一个数据被用到时，其附近的数据也通常会马上被使用」。为了满足局部性原理， 所以应该将逻辑上相邻的数据在物理上也尽量存储在一起，这样才能减少读写磁盘的数量。</p>
<p>  相比一个节点只能存储一个数据的 BST 类数据结构来，B-Tree更「胖」、更加「扁平」，即每个节点能容纳更多的数据， 这样就能降低树的高度，同时让逻辑上相邻的数据都能尽量存储在物理上也相邻的硬盘空间上，减少磁盘读写。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://www.goodserendipity.com/2023/08/01/DataStructuresAndAlgorithms/30%E3%80%81Red-Black%20Tree/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Louis">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="缘分天注定">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/08/01/DataStructuresAndAlgorithms/30%E3%80%81Red-Black%20Tree/" class="post-title-link" itemprop="url">Red-Black Tree</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-08-01 14:34:17" itemprop="dateCreated datePublished" datetime="2023-08-01T14:34:17+08:00">2023-08-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-08-12 18:10:20" itemprop="dateModified" datetime="2023-08-12T18:10:20+08:00">2023-08-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">数据结构与算法</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>  <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Red%E2%80%93black_tree">Red-Black Tree</a>红黑树是一种自平衡的二叉搜索树。每个节点额外存储了一个 color 字段 (“RED” or “BLACK”)，用于确保树在插入和删除时保持平衡。<a target="_blank" rel="noopener" href="https://www.cs.usfca.edu/~galles/visualization/RedBlack.html">红黑树的可视化</a>，<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1BB4y1X7u3/?spm_id_from=333.788&amp;vd_source=219182b04373881442d7f47ca556521b">喵的算法课-红黑树</a>。</p>
<h3 id="红黑树的历史"><a class="markdownIt-Anchor" href="#红黑树的历史"></a> 红黑树的历史</h3>
<ol>
<li>1972 年，Rudolf Bayer 提出了 <a target="_blank" rel="noopener" href="https://docs.lib.purdue.edu/cgi/viewcontent.cgi?article=1457&amp;context=cstech">symmetric binary B-tree</a>，这是B 树的 4 阶情形，也就是 2-3-4树（或称为 2-4 树）。</li>
<li>1978 年，Leonidas J. Guibas 和 Robert Sedgewick 的论文<a target="_blank" rel="noopener" href="https://sedgewick.io/wp-content/themes/sedgewick/papers/1978Dichromatic.pdf">A Dichromatic Framework for Balanced Trees</a>从 symmetric binary B-tree 推导出红黑树。</li>
<li>1993 年，Arne Andersson 引入 right leaning tree(右倾树) 的概念来简化插入和删除操作，即<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/AA_tree">AA Tree</a>。</li>
<li>1999 年，Chris Okasaki 在论文<a target="_blank" rel="noopener" href="https://www.cs.tufts.edu/comp/150FP/archive/chris-okasaki/redblack99.pdf">FUNCTIONAL PEARLS – Red-Black Trees in a Functional Setting</a>中展示了如何使插入操作成为纯函数，只需处理 4 种失衡类型和 1 种默认平衡类型。</li>
<li>2001 年，Cormen 等人在 Introduction to Algorithms, Second Edition 中将原算法的 8 个失衡类型减少为 6 个失衡类型。</li>
<li>2008 年，Sedgewick 根据 Andersson 的思想，提出了 <a target="_blank" rel="noopener" href="https://sedgewick.io/wp-content/themes/sedgewick/papers/2008LLRB.pdf">Left leaning red black tree</a>(左倾红黑树)，这是 2-3 树的等价转换。</li>
</ol>
<h3 id="红黑树的定义"><a class="markdownIt-Anchor" href="#红黑树的定义"></a> 红黑树的定义</h3>
<ol>
<li>每个节点是红色或者黑色</li>
<li>头结点是黑色</li>
<li>叶子节点(最底层不存放数据的节点)都是黑色，且都为空</li>
<li>红色节点的父节点和子节点都为黑色(紅色节点不能相连)</li>
<li>从任一节点到叶子节点的所有路径都包含相同数量的黑色节点</li>
</ol>
<p>  最长链红色黑色相间，最短链都是黑色，长度相差不超过两倍。保证红黑树不会退化成链表，路径长度控制在2倍以内保证查询效率。</p>
<h3 id="红黑树与2-3-4-tree的关系"><a class="markdownIt-Anchor" href="#红黑树与2-3-4-tree的关系"></a> 红黑树与2-3-4 Tree的关系</h3>
<ol>
<li>红黑树的红色节点上移到父节点，形成一个2-3-4 Tree，红黑树和2-3-4Tree是等价的。</li>
<li>红黑树的黑色节点个数=2-3-4Tree的节点个数。</li>
<li>2-3-4树的每一个节点中:黑色节点必为父节点，红色节点为子节点(黑色在中间，红色在两边)</li>
</ol>
<h3 id="红黑树的时间复杂度证明"><a class="markdownIt-Anchor" href="#红黑树的时间复杂度证明"></a> 红黑树的时间复杂度证明</h3>
<p>  通过数学归纳法证明<strong>定理：一棵含有n个节点的红黑树的高度至多为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mo>×</mo><mi mathvariant="normal">Θ</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">2 \times \Theta (log(n+1))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></strong>。它的逆否命题是 <strong>高度为h的红黑树，它的包含的内节点个数至少为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mfrac><mi>h</mi><mn>2</mn></mfrac></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2 ^ \frac{h}{2} - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.06235em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.97902em;"><span style="top:-3.363em;margin-right:0.05em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen nulldelimiter sizing reset-size3 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8800285714285714em;"><span style="top:-2.656em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.2255000000000003em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line mtight" style="border-bottom-width:0.049em;"></span></span><span style="top:-3.384em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">h</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.344em;"><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size3 size6"></span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 个</strong>。只需要证明逆否命题，即可证明原命题为真。</p>
<p>  从某个节点x出发（不包括该节点）到达一个叶节点的任意一条路径上，黑色节点的个数称为该节点的黑高度(x’s black height)，记为bh(x)。关于bh(x):</p>
<ol>
<li>bh(x)的值是唯一的(红黑树的性质5，从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点)</li>
<li>bh(x) ≥ <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mi>h</mi><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">\frac{h}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2251079999999999em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8801079999999999em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">h</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>（根据红黑树的性质4，从节点x出发达到叶节点所经历的黑节点数目 ≥ 所经历的红节点的数目)</li>
</ol>
<p>  只需证明<strong>高度为h的红黑树，它的包含的黑节点个数至少为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mrow><mi>b</mi><mi>h</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^{bh(x)} -1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9713299999999999em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8879999999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">b</span><span class="mord mathnormal mtight">h</span><span class="mopen mtight">(</span><span class="mord mathnormal mtight">x</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 个</strong>即可，数学归纳法论证过程如下：</p>
<ol>
<li>当树的高度h = 0时，内节点个数是0，bh(x) 为0，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mrow><mi>b</mi><mi>h</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^{bh(x)} -1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9713299999999999em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8879999999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">b</span><span class="mord mathnormal mtight">h</span><span class="mopen mtight">(</span><span class="mord mathnormal mtight">x</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 也为 0。显然，原命题成立。</li>
<li>当h &gt; 0，且树的高度为 h-1 时，它包含的节点个数至少为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mrow><mi>b</mi><mi>h</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>−</mo><mn>1</mn></mrow></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^{bh(x)-1} -1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9713299999999999em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8879999999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">b</span><span class="mord mathnormal mtight">h</span><span class="mopen mtight">(</span><span class="mord mathnormal mtight">x</span><span class="mclose mtight">)</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>。</li>
</ol>
<blockquote>
<p>由树的高度为 h-1 的已知条件推出“树的高度为 h 时，它所包含的节点树为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mrow><mi>b</mi><mi>h</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^{bh(x)} -1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9713299999999999em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8879999999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">b</span><span class="mord mathnormal mtight">h</span><span class="mopen mtight">(</span><span class="mord mathnormal mtight">x</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 。<br />
当树的高度为 h 时，<br />
对于节点x(x为根节点)，其黑高度为bh(x)。<br />
对于节点x的左右子树，它们黑高度为 bh(x) 或者 bh(x)-1。<br />
x的左右子树，即高度为 h-1 的节点，它包含的节点至少为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mrow><mi>b</mi><mi>h</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>−</mo><mn>1</mn></mrow></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^{bh(x)-1} -1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9713299999999999em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8879999999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">b</span><span class="mord mathnormal mtight">h</span><span class="mopen mtight">(</span><span class="mord mathnormal mtight">x</span><span class="mclose mtight">)</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> ；<br />
所以，节点x所包含的节点至少为 ( <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mrow><mi>b</mi><mi>h</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>−</mo><mn>1</mn></mrow></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^{bh(x)-1} -1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9713299999999999em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8879999999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">b</span><span class="mord mathnormal mtight">h</span><span class="mopen mtight">(</span><span class="mord mathnormal mtight">x</span><span class="mclose mtight">)</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> ) + ( <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mrow><mi>b</mi><mi>h</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>−</mo><mn>1</mn></mrow></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^{bh(x)-1} -1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9713299999999999em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8879999999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">b</span><span class="mord mathnormal mtight">h</span><span class="mopen mtight">(</span><span class="mord mathnormal mtight">x</span><span class="mclose mtight">)</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> ) + 1 = <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mrow><mi>b</mi><mi>h</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^{bh(x)} -1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9713299999999999em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8879999999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">b</span><span class="mord mathnormal mtight">h</span><span class="mopen mtight">(</span><span class="mord mathnormal mtight">x</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>。即节点x所包含的节点至少为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mrow><mi>b</mi><mi>h</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^{bh(x)} -1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9713299999999999em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8879999999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">b</span><span class="mord mathnormal mtight">h</span><span class="mopen mtight">(</span><span class="mord mathnormal mtight">x</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>。<br />
因此，原命题成立。</p>
</blockquote>
<h3 id="红黑树插入操作"><a class="markdownIt-Anchor" href="#红黑树插入操作"></a> 红黑树插入操作</h3>
<ol>
<li>如果插入的是根节点，则为黑色</li>
<li>其余情况插入的节点最开始一定为红色(如果是插入红色节点，仅有一种冲突情况，就是可能出现连续两个红色节点，这时候只需要旋转和变色进行调整)</li>
<li>红黑树的插入操作分为12中情况
<ol>
<li>插入节点的父节点为黑色(4种情况)，直接插入，不做调整</li>
<li>叔父节点不是红色(4中情况)，变色加旋转(叔父节点不是红色，则只能是黑色的叶子节点，如果不是叶子节点则破坏了性质5)</li>
<li>叔父节点是红色(4种上溢情况)，变色，向上递归</li>
</ol>
</li>
</ol>
<p><img src="https://www.goodserendipity.com/asserts/data-structures-and-algorithms/red-black%20tree%20insert.png" alt="红黑树插入" /></p>
<h3 id="红黑树删除操作"><a class="markdownIt-Anchor" href="#红黑树删除操作"></a> 红黑树删除操作</h3>
<p>  算法(第4版)，展示了2-3树为基础的左倾红黑树。也可以2-3-4树为基础理解红黑树。1个B树节点=以黑色节点为主，若有红色节点则在其两边。B树中的删除操作，对于非叶子节点是转换为其前驱/后继节点的删除，将要删除的节 点和前驱/后继节点数据交换，然后删除。</p>
<ol>
<li>红色节点可以直接删除</li>
<li>黑色节点的删除(从任一节点到叶子节点的所有路径，都包含相同的黑色节点)
<ol>
<li>有2个子节点的黑色节点(4节点)，(不做考虑，会转化为对子节点的删除，待删除节点的前驱/后继节点最多只有一个子节点)</li>
<li>有1个红色子节点的黑色节点(3节点)，用唯一的红色子节点来替代被删除的节点(红色子节点替代、删除节点、染黑)(有1个黑色子节点的黑色节点，这个黑色子节点只能是叶子节点)</li>
<li>没有子节点的黑色节点(2节点)</li>
</ol>
<ul>
<li>删除节点为根节点，直接删除(整个红黑树只有这一个黑色节点，没有红色子节点，所以只有一个节点)</li>
<li>删除节点的兄弟节点为黑色
<ul>
<li>兄弟节点有红色子节点(借用兄弟子节点修复)
<ul>
<li>红色左子节点，父节点单旋不染色</li>
<li>红色右子节点，兄弟节点左旋，父节点右旋，父节点染黑</li>
<li>两个红色子节点，可以选择左子节点/右子节点</li>
</ul>
</li>
<li>兄弟节点没有红色子节点(父节点向下合并)
<ul>
<li>父节点是红色，父节点染黑，兄弟节点染红</li>
<li>父节点是黑色，把父节点当做已经被删除的节点处理，向上递归染色</li>
</ul>
</li>
</ul>
</li>
<li>删除节点的兄弟节点为红色(转变为兄弟节点为黑色)
<ul>
<li>兄弟节点染黑，父节点染红，父节点右旋</li>
</ul>
</li>
</ul>
</li>
</ol>
<p><img src="https://www.goodserendipity.com/asserts/data-structures-and-algorithms/rbtree%20delete1.png" alt="红黑树的删除操作" /></p>
<p>  兄弟节点没有红色子节点</p>
<p><img src="https://www.goodserendipity.com/asserts/data-structures-and-algorithms/rbtree%20delete2.png" alt="红黑树的删除操作" /></p>
<h3 id="红黑树的特点"><a class="markdownIt-Anchor" href="#红黑树的特点"></a> 红黑树的特点</h3>
<ol>
<li>平衡性规定非常特别</li>
<li>平衡性调整最为复杂</li>
<li>优点在于每次插入删除扰动较好，但是在今天看来这个优势也极其微弱了。贪图扰动小的话，B+树、2-3-4树可能更好</li>
<li>除此之外，红黑树并不比AVL树、SB树、跳表更加优秀</li>
<li>数组、hashmap等扩容的时间复杂度均摊下来就是O(1)</li>
<li>234树、B树、B+树、红黑树等平衡性相对不严格，只需要在调整平衡性的时候进行磁盘IO，用于硬盘相关，主要减少磁盘IO，而AVL Tree平衡性好，但是对磁盘IO比较敏感。</li>
<li>插入删除、查询的时间复杂度都是O(logN)，严格证明涉及概率。</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://www.goodserendipity.com/2023/08/01/DataStructuresAndAlgorithms/29%E3%80%812-3-4%20Tree/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Louis">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="缘分天注定">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/08/01/DataStructuresAndAlgorithms/29%E3%80%812-3-4%20Tree/" class="post-title-link" itemprop="url">2-3-4 Tree</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-08-01 14:33:55" itemprop="dateCreated datePublished" datetime="2023-08-01T14:33:55+08:00">2023-08-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-08-12 18:06:58" itemprop="dateModified" datetime="2023-08-12T18:06:58+08:00">2023-08-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">数据结构与算法</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>  <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/2%E2%80%933%E2%80%934_tree">2-3-4 Tree</a>是一种多叉树，也叫作234树/4阶B树。2-3-4 Tree是有序的，每个元素必须大于或等于它左边的和左子树的任何元素。每棵2-3-4 Tree存在至少一棵数据元素顺序相同的红黑树，但2-3-4 Tree的实现更难，一般都使用红黑树。2-3 Tree也等价于红黑树。它的每个节点最多有3个数据项和4个子节点，分为3类，分别是2节点、3节点、4节点。2节点有一个数据项，2个子节点，3节点有两个数据项，3个子节点，4节点有三个数据项，4个子节点。节点数据项和子节点数量的变化都会导致上溢、下溢。<br />
<img src="https://www.goodserendipity.com/asserts/data-structures-and-algorithms/2-3-4%20Tree.png" alt="2-3-4 Tree新增节点上溢" /></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://www.goodserendipity.com/2023/07/27/Linux/monitor/1%E3%80%81nmon/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Louis">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="缘分天注定">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/07/27/Linux/monitor/1%E3%80%81nmon/" class="post-title-link" itemprop="url">nmon</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-07-27 00:47:49 / Modified: 00:48:07" itemprop="dateCreated datePublished" datetime="2023-07-27T00:47:49+08:00">2023-07-27</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/monitor/" itemprop="url" rel="index"><span itemprop="name">monitor</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://www.goodserendipity.com/2023/07/25/DataStructuresAndAlgorithms/42%E3%80%81%E5%90%8E%E7%BC%80%E6%A0%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Louis">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="缘分天注定">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/07/25/DataStructuresAndAlgorithms/42%E3%80%81%E5%90%8E%E7%BC%80%E6%A0%91/" class="post-title-link" itemprop="url">后缀树</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-07-25 19:41:03" itemprop="dateCreated datePublished" datetime="2023-07-25T19:41:03+08:00">2023-07-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-08-13 12:40:46" itemprop="dateModified" datetime="2023-08-13T12:40:46+08:00">2023-08-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">数据结构与算法</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="词频统计"><a class="markdownIt-Anchor" href="#词频统计"></a> 词频统计</h3>
<p>  一个文本文件，有1W行，每行一个词，要求统计最频繁出现的10个词。</p>
<h3 id="原地词频统计"><a class="markdownIt-Anchor" href="#原地词频统计"></a> 原地词频统计</h3>
<p>  1G大小的文件，每一行是一个词，词的大小不超过16字节，内存限制1M。返回频数最高的100个词。</p>
<h3 id="字符串去重"><a class="markdownIt-Anchor" href="#字符串去重"></a> 字符串去重</h3>
<p>  1000W字符串，去除重复的字符串。</p>
<h3 id="搜索引擎词频统计"><a class="markdownIt-Anchor" href="#搜索引擎词频统计"></a> 搜索引擎词频统计</h3>
<p>  热门查询，搜索引擎记录用户每次检索的关键字1000W个，去重后不超过300W。要求统计出现频率最高的10个查询串，内存不能超过1G。<br />
  考虑bitmap、hashmap、trie树统计每个词出现的次数、堆</p>
<h3 id="最长回文子串"><a class="markdownIt-Anchor" href="#最长回文子串"></a> 最长回文子串</h3>
<p>  后缀树(算法实现复杂并且空间开销大)</p>
<h3 id="字符串包含"><a class="markdownIt-Anchor" href="#字符串包含"></a> 字符串包含</h3>
<p>  字符串S是否包含子串S1<br />
  在S的后缀树中查找S1</p>
<h3 id="最长重复子串"><a class="markdownIt-Anchor" href="#最长重复子串"></a> 最长重复子串</h3>
<p>  找出字符串S的最长重复子串S1</p>
<h3 id="最长公共子串"><a class="markdownIt-Anchor" href="#最长公共子串"></a> 最长公共子串</h3>
<p>  找出S1和S2的最长公共子串<br />
  最长公共子串和最长公共子序列的区别，子串是连续的，子序列是不连续的但是不更改在原字符串中的顺序。<br />
  考虑后缀树、动态规划</p>
<h3 id="ziv-lampel无损压缩算法"><a class="markdownIt-Anchor" href="#ziv-lampel无损压缩算法"></a> Ziv-Lampel无损压缩算法</h3>
<p>  后缀树的形式存储字符串和压缩码值的字典，因为编码数据存在大量的重复字符串</p>
<h3 id="多模式串的匹配问题"><a class="markdownIt-Anchor" href="#多模式串的匹配问题"></a> 多模式串的匹配问题</h3>
<p>  后缀数组加二分</p>
<h3 id="后缀树的构造方法"><a class="markdownIt-Anchor" href="#后缀树的构造方法"></a> 后缀树的构造方法</h3>
<p>  Ukkonen</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Louis</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">69</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">17</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">101</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Louis</span>
  </br>
<span>&nbsp;<a target="_blank" rel="noopener" href="http://beian.miit.gov.cn/">鄂ICP备2023000734号-1</a></span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  
      
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex@0/dist/katex.min.css">
  <script src="//cdn.jsdelivr.net/npm/katex@0/dist/contrib/copy-tex.min.js"></script>
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex@0/dist/contrib/copy-tex.min.css">


  

</body>
</html>
